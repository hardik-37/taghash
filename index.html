<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Maze Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            background-color: #f0f4f8; /* A light, pleasant background for the maze */
            touch-action: none; /* Prevents scrolling on mobile when swiping */
        }
        /* Style for the player and exit for better visibility */
        .player { background-color: #3b82f6; }
        .exit { background-color: #10b981; }
        .wall { background-color: #334155; }
    </style> -->

<style>
  :root {
    --bg1: #121213;
    --bg2: #1a1a40;
    --bg3: #0f2027;
    --tile-border: #3a3a3c;
    --correct: #538d4e;
    --present: #b59f3b;
    --absent: #3a3a3c;
    --text: #ffffff;
    --key-bg: #818384;
    --key-text: #ffffff;
  }

  /* Animated gradient background */
  body {
    margin: 0;
    color: var(--text);
    font-family: Arial, Helvetica, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    justify-content: center;
    /* background: linear-gradient(-45deg, #0f2027, #df7519, #ffa033, #a4a4ff); */
    /* background: linear-gradient(135deg, #f3f4f6, #e5e7eb); */

    /* background-size: 400% 400%;
    animation: gradientMove 10s ease infinite; */
     background-image: url('/bg2.png'); /* update path */
  background-size: cover; /* make image fill the screen */
  background-position: center; /* center the image */
  background-repeat: no-repeat; /* prevent repeating */
  }

  @keyframes gradientMove {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  #board {
    display: grid;
    grid-template-rows: repeat(6, 1fr);
    gap: 5px;
    margin-bottom: 30px;
  }

  .row {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 5px;
  }

  .tile {
    width: 60px;
    height: 60px;
    border: 2px solid var(--tile-border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    font-weight: bold;
    text-transform: uppercase;
    color: var(--text);
    transition: background-color 0.3s, transform 0.3s;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
  }

  .correct { background-color: var(--correct); border-color: var(--correct); }
  .present { background-color: var(--present); border-color: var(--present); }
  .absent { background-color: var(--absent); border-color: var(--absent); }

  #keyboard {
    display: flex;
    flex-direction: column;
    gap: 6px;
    justify-content: center;
    align-items: center;
  }

  .key-row {
    display: flex;
    gap: 6px;
  }

  .key {
    background-color: var(--key-bg);
    color: var(--key-text);
    border: none;
    padding: 14px 10px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    text-transform: uppercase;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    transition: transform 0.1s ease;
  }

  .key:hover {
    transform: scale(1.05);
  }

  .key.wide { width: 70px; }
  .key:active { opacity: 0.7; }

  @media (max-width: 600px) {
    .tile { width: 48px; height: 48px; font-size: 1.5rem; }
  }

  #message {
    position: fixed;
    top: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 20px;
    border-radius: 6px;
    font-weight: bold;
    display: none;
  }

  #modal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    visibility: hidden;
  }

  #modalContent {
    background: #222;
    padding: 20px 30px;
    border-radius: 10px;
    text-align: center;
    color: white;
    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
  }

  #modal a, #tryAgainBtn {
    display: inline-block;
    margin-top: 15px;
    background-color: var(--correct);
    color: white;
    padding: 10px 16px;
    border-radius: 6px;
    text-decoration: none;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  #modal a:hover, #tryAgainBtn:hover {
    transform: scale(1.05);
  }

  .logo img {
    width: 30vw;
    margin: 0 auto;
    padding: 30px 0px;
    filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));
  }
.top-logo{
    width: 30vw;
}


  #tryAgainBtn { background-color: var(--present); }
</style>

</head>
<body class="bg-slate-900 flex items-center justify-center min-h-screen p-4">
<div class="logos"><img class="top-logo" src="./Taghash.png" alt=""></div>
    <div class="w-full max-w-lg mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-8 text-center">
        
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-800">The Maze Challenge</h1>
            <p class="text-slate-500 mt-2">Guide the player to the green exit to reveal the secret link!</p>
        </header>

        <!-- Game Canvas and Success Modal Container -->
        <div class="relative w-full max-w-md mx-auto aspect-square">
            <canvas id="mazeCanvas" class="rounded-lg border-2 border-slate-200"></canvas>
            
            <!-- Success Modal -->
            <div id="successModal" class="hidden absolute inset-0 bg-black bg-opacity-80 rounded-lg flex flex-col items-center justify-center text-white p-4 transition-opacity duration-300">
                <h2 class="text-3xl font-bold text-green-400">Congratulations!</h2>
                <p class="mt-2 mb-6">You've solved the maze.</p>
                
                <div class="bg-slate-700 p-4 rounded-lg w-full max-w-xs">
                    <p class="text-sm text-slate-300 mb-2">Here is your secret link:</p>
                    <a id="finalLink" href="#" target="_blank" class="text-blue-400 hover:underline break-all"></a>
                </div>
                
                <div class="flex space-x-4 mt-6">
                    <button onclick="copyLink()" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">
                        Copy Link
                    </button>
                    <button onclick="resetGame()" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">
                        Play Again
                    </button>
                </div>
                 <p id="copy-feedback" class="text-sm mt-4 opacity-0 transition-opacity duration-300">Link copied to clipboard!</p>
            </div>
        </div>


    </div>

    <script>
        // --- CONFIGURATION ---
        // Change this link to your desired final destination
        const FINAL_LINK = "https://docs.google.com/forms/d/e/1FAIpQLSfzUW0lIAfoSjTuCGXIacWlmmzNm5sIG5lhtBXcKnYy7RF5JQ/viewform?usp=header";

        // --- GAME LOGIC ---
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const successModal = document.getElementById('successModal');
        const finalLinkElement = document.getElementById('finalLink');
        const copyFeedback = document.getElementById('copy-feedback');

        // Maze layout: 0 = path, 1 = wall, 2 = player start, 3 = exit
        const maze = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
            [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        let tileSize;
        let player = { x: 0, y: 0 };
        let exit = { x: 0, y: 0 };
        let isGameOver = false;

        // Touch swipe variables
        let touchstartX = 0;
        let touchstartY = 0;
        let touchendX = 0;
        let touchendY = 0;
        const swipeThreshold = 50; // Minimum distance for a swipe

        function findStartAndExit() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 2) {
                        player.x = x;
                        player.y = y;
                    } else if (maze[y][x] === 3) {
                        exit.x = x;
                        exit.y = y;
                    }
                }
            }
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvas.width = size;
            canvas.height = size;
            tileSize = canvas.width / maze.length;
            drawGame();
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    ctx.beginPath();
                    // Wall
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#334155'; // slate-700
                    // Exit
                    } else if (maze[y][x] === 3) {
                        ctx.fillStyle = '#10b981'; // emerald-500
                    // Path
                    } else {
                        ctx.fillStyle = 'transparent'; 
                    }
                    ctx.rect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.fill();
                }
            }

            // Draw Player
            ctx.beginPath();
            ctx.fillStyle = '#3b82f6'; // blue-500
            ctx.arc(
                player.x * tileSize + tileSize / 2,
                player.y * tileSize + tileSize / 2,
                tileSize / 3, // Player radius
                0,
                2 * Math.PI
            );
            ctx.fill();
        }

        function movePlayer(dx, dy) {
            if (isGameOver) return;
            
            let newX = player.x + dx;
            let newY = player.y + dy;

            // Check for valid move (not a wall)
            if (maze[newY] && maze[newY][newX] !== 1) {
                player.x = newX;
                player.y = newY;
                drawGame();
                checkWinCondition();
            }
        }

        function handleKeyPress(e) {
            e.preventDefault();
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                    movePlayer(0, 1); // Up key moves player Down
                    break;
                case 'ArrowDown':
                case 's':
                    movePlayer(0, -1); // Down key moves player Up
                    break;
                case 'ArrowLeft':
                case 'a':
                    movePlayer(1, 0); // Left key moves player Right
                    break;
                case 'ArrowRight':
                case 'd':
                    movePlayer(-1, 0); // Right key moves player Left
                    break;
            }
        }
        
        function handleSwipe() {
            const dx = touchendX - touchstartX;
            const dy = touchendY - touchstartY;

            if (Math.abs(dx) > Math.abs(dy)) { // Horizontal swipe
                if (Math.abs(dx) > swipeThreshold) {
                    if (dx > 0) { // Swipe Right
                        movePlayer(-1, 0); // Moves player Left
                    } else { // Swipe Left
                        movePlayer(1, 0); // Moves player Right
                    }
                }
            } else { // Vertical swipe
                if (Math.abs(dy) > swipeThreshold) {
                    if (dy > 0) { // Swipe Down
                        movePlayer(0, -1); // Moves player Up
                    } else { // Swipe Up
                        movePlayer(0, 1); // Moves player Down
                    }
                }
            }
        }

        function checkWinCondition() {
            if (player.x === exit.x && player.y === exit.y) {
                isGameOver = true;
                finalLinkElement.href = FINAL_LINK;
                finalLinkElement.textContent = FINAL_LINK;
                successModal.classList.remove('hidden');
            }
        }

        window.resetGame = function() {
            isGameOver = false;
            successModal.classList.add('hidden');
            copyFeedback.classList.add('opacity-0');
            findStartAndExit();
            drawGame();
        }
        
        window.copyLink = function() {
            const tempInput = document.createElement('input');
            document.body.appendChild(tempInput);
            tempInput.value = FINAL_LINK;
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);

            copyFeedback.classList.remove('opacity-0');
            setTimeout(() => {
                copyFeedback.classList.add('opacity-0');
            }, 2000);
        }

        // Initial setup
        window.addEventListener('load', () => {
            findStartAndExit();
            resizeCanvas();
        });
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('keydown', handleKeyPress);

        // Add touch event listeners for swipe controls
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            touchstartX = e.changedTouches[0].screenX;
            touchstartY = e.changedTouches[0].screenY;
        }, { passive: false });

        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            touchendX = e.changedTouches[0].screenX;
            touchendY = e.changedTouches[0].screenY;
            handleSwipe();
        }, { passive: false });
    </script>
</body>
</html>
