<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Maze Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            background-color: #f0f4f8; /* A light, pleasant background for the maze */
            touch-action: none; /* Prevents scrolling on mobile when swiping */
        }
        /* Style for the player and exit for better visibility */
        .player { background-color: #3b82f6; }
        .exit { background-color: #10b981; }
        .wall { background-color: #334155; }
    </style>
</head>
<body class="bg-slate-900 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-lg mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-8 text-center">
        
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-800">The Maze Challenge</h1>
            <p class="text-slate-500 mt-2">Guide the player to the green exit to reveal the secret link!</p>
        </header>

        <!-- Game Canvas and Success Modal Container -->
        <div class="relative w-full max-w-md mx-auto aspect-square">
            <canvas id="mazeCanvas" class="rounded-lg border-2 border-slate-200"></canvas>
            
            <!-- Success Modal -->
            <div id="successModal" class="hidden absolute inset-0 bg-black bg-opacity-80 rounded-lg flex flex-col items-center justify-center text-white p-4 transition-opacity duration-300">
                <h2 class="text-3xl font-bold text-green-400">Congratulations!</h2>
                <p class="mt-2 mb-6">You've solved the maze.</p>
                
                <div class="bg-slate-700 p-4 rounded-lg w-full max-w-xs">
                    <p class="text-sm text-slate-300 mb-2">Here is your secret link:</p>
                    <a id="finalLink" href="#" target="_blank" class="text-blue-400 hover:underline break-all"></a>
                </div>
                
                <div class="flex space-x-4 mt-6">
                    <button onclick="copyLink()" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">
                        Copy Link
                    </button>
                    <button onclick="resetGame()" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">
                        Play Again
                    </button>
                </div>
                 <p id="copy-feedback" class="text-sm mt-4 opacity-0 transition-opacity duration-300">Link copied to clipboard!</p>
            </div>
        </div>

        <footer class="mt-6">
            <p class="text-slate-500 font-medium">Use <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Arrow Keys</kbd> or <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">WASD</kbd> to move.</p>
            <p class="text-slate-500 font-medium mt-2 md:hidden">On mobile, swipe opposite to the direction you want to go.</p>
        </footer>
    </div>

    <script>
        // --- CONFIGURATION ---
        // Change this link to your desired final destination
        const FINAL_LINK = "https://taghash.io/";

        // --- GAME LOGIC ---
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const successModal = document.getElementById('successModal');
        const finalLinkElement = document.getElementById('finalLink');
        const copyFeedback = document.getElementById('copy-feedback');

        // Maze layout: 0 = path, 1 = wall, 2 = player start, 3 = exit
        const maze = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
            [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        let tileSize;
        let player = { x: 0, y: 0 };
        let exit = { x: 0, y: 0 };
        let isGameOver = false;

        // Touch swipe variables
        let touchstartX = 0;
        let touchstartY = 0;
        let touchendX = 0;
        let touchendY = 0;
        const swipeThreshold = 50; // Minimum distance for a swipe

        function findStartAndExit() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 2) {
                        player.x = x;
                        player.y = y;
                    } else if (maze[y][x] === 3) {
                        exit.x = x;
                        exit.y = y;
                    }
                }
            }
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvas.width = size;
            canvas.height = size;
            tileSize = canvas.width / maze.length;
            drawGame();
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    ctx.beginPath();
                    // Wall
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#334155'; // slate-700
                    // Exit
                    } else if (maze[y][x] === 3) {
                        ctx.fillStyle = '#10b981'; // emerald-500
                    // Path
                    } else {
                        ctx.fillStyle = 'transparent'; 
                    }
                    ctx.rect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.fill();
                }
            }

            // Draw Player
            ctx.beginPath();
            ctx.fillStyle = '#3b82f6'; // blue-500
            ctx.arc(
                player.x * tileSize + tileSize / 2,
                player.y * tileSize + tileSize / 2,
                tileSize / 3, // Player radius
                0,
                2 * Math.PI
            );
            ctx.fill();
        }

        function movePlayer(dx, dy) {
            if (isGameOver) return;
            
            let newX = player.x + dx;
            let newY = player.y + dy;

            // Check for valid move (not a wall)
            if (maze[newY] && maze[newY][newX] !== 1) {
                player.x = newX;
                player.y = newY;
                drawGame();
                checkWinCondition();
            }
        }

        function handleKeyPress(e) {
            e.preventDefault();
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                    movePlayer(0, 1); // Up key moves player Down
                    break;
                case 'ArrowDown':
                case 's':
                    movePlayer(0, -1); // Down key moves player Up
                    break;
                case 'ArrowLeft':
                case 'a':
                    movePlayer(1, 0); // Left key moves player Right
                    break;
                case 'ArrowRight':
                case 'd':
                    movePlayer(-1, 0); // Right key moves player Left
                    break;
            }
        }
        
        function handleSwipe() {
            const dx = touchendX - touchstartX;
            const dy = touchendY - touchstartY;

            if (Math.abs(dx) > Math.abs(dy)) { // Horizontal swipe
                if (Math.abs(dx) > swipeThreshold) {
                    if (dx > 0) { // Swipe Right
                        movePlayer(-1, 0); // Moves player Left
                    } else { // Swipe Left
                        movePlayer(1, 0); // Moves player Right
                    }
                }
            } else { // Vertical swipe
                if (Math.abs(dy) > swipeThreshold) {
                    if (dy > 0) { // Swipe Down
                        movePlayer(0, -1); // Moves player Up
                    } else { // Swipe Up
                        movePlayer(0, 1); // Moves player Down
                    }
                }
            }
        }

        function checkWinCondition() {
            if (player.x === exit.x && player.y === exit.y) {
                isGameOver = true;
                finalLinkElement.href = FINAL_LINK;
                finalLinkElement.textContent = FINAL_LINK;
                successModal.classList.remove('hidden');
            }
        }

        window.resetGame = function() {
            isGameOver = false;
            successModal.classList.add('hidden');
            copyFeedback.classList.add('opacity-0');
            findStartAndExit();
            drawGame();
        }
        
        window.copyLink = function() {
            const tempInput = document.createElement('input');
            document.body.appendChild(tempInput);
            tempInput.value = FINAL_LINK;
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);

            copyFeedback.classList.remove('opacity-0');
            setTimeout(() => {
                copyFeedback.classList.add('opacity-0');
            }, 2000);
        }

        // Initial setup
        window.addEventListener('load', () => {
            findStartAndExit();
            resizeCanvas();
        });
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('keydown', handleKeyPress);

        // Add touch event listeners for swipe controls
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            touchstartX = e.changedTouches[0].screenX;
            touchstartY = e.changedTouches[0].screenY;
        }, { passive: false });

        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            touchendX = e.changedTouches[0].screenX;
            touchendY = e.changedTouches[0].screenY;
            handleSwipe();
        }, { passive: false });
    </script>
</body>
</html>

